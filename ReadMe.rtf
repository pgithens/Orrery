{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Paul Githens\
ReadMe\
Assignment 7\
November 14, 2018\
\
To begin I created new variables. I created a variable to pass the texture coordinates to the vertex shader, a variable to pass the texture sampler to the fragment shader, a texture variable for each sphere being created an array of the texture coordinate data and a variable to store the texture coordinate buffer. I also had a variable that tracked the rotation of the earth about its axis. \
\
In the init() function, I handled the texture coordinate buffer by creating, binding and then storing the buffer data. I also activated a texture, gl.TEXTURE0, and handled the texture sampler and sent it to the fragment shader. \
\
In setUpSphere(), I added three lines of code that calculated the u and v values of each vertex in each sphere and added it to the texture coordinate array. \
\
In drawSphere(), I changed the color of each planet to white so that the texture would not be influenced by the color that the planet was before the texture was added. I also bound a texture to the specific sphere that was being rendered based on a variable passed in from the drawBodies() function, this variable was the texture of the body which was to be drawn. I then passed the texture coordinate buffer to the fragment shader and called the vertexAttribPointer on the texture coordinate variable that was passed into the fragment shader. \
\
In drawBodies(), I added a new value that the movement matrix of earth will be multiplied by, a rotate Y of a value that is counting up from zero each day being incremented by a variable that contains the value for the rotation of the earth each frame based on the current frames per day times 360.\
\
Created two new functions, handleLoadedTexture(), which takes in a texture and applies the functions: pixelStorei, bindTexture, texImage2D, texParameteri, texParameteri, and generateMipmap on the texture and using a number of builtin values from webGL. \
In initTexture() each sphere is dealt with in order, sun, mercury, venus, earth, moon. The dealing with is creating a gl texture object, preparing a new image for the texture object and calling the handleLoadedTexture function on the load. initTexture() is called in the init() function. \
\
In render(), the earthRotate value is incremented.\
\
In the vertex shader, the texture coordinate variable is passed into the fragment shader. \
\
In the fragment shader, a variable is created called textureColor whose value is the result of the texture2D method being called on the texture sampler and the texture first and second values of the texture coordinates. Then, when the spheres are being rendered, which is also when the light is being used so the if statement from last time can be used, the texture color rgb is multiplied by the v_fColor rgb, which takes into account the lighting, and the fourth value is the alpha value of the texture, which is the textures opacity. \
\
}